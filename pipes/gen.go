package pipes

import (
	"fmt"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io"
	"os"
	"regexp"

	"github.com/dave/jennifer/jen"
	"github.com/pkg/errors"
)

var pipeRegex = regexp.MustCompile(`//\s?@pipe.*`)

const defaultFunctionName = "Invoke"

const (
	// StageTypeFunction ...
	StageTypeFunction = iota
	// StageTypeFunctor ...
	StageTypeFunctor
)

// StageType ...
type StageType int

type stage struct {
	name         string
	stateType    StageType
	functor      *Functor
	paramIndices []int
}

// Functor ...
type Functor struct {
	name      string
	signature *types.Signature
}

// Generator ...
type Generator struct {
	path          string
	file          *jen.File
	info          *types.Info
	functors      map[*types.Named]*Functor
	writerFactory WriterFactory
}

// NewGenerator ...
func NewGenerator(path string, opts ...Option) *Generator {
	generator := &Generator{
		path:     path,
		functors: map[*types.Named]*Functor{},
	}

	for _, opt := range opts {
		opt(generator)
	}

	if generator.writerFactory == nil {
		generator.writerFactory = NewStringWriterFactory()
	}

	return generator
}

// Execute ...
func (g *Generator) Execute() error {
	if err := g.ensureDir(); err != nil {
		return err
	}

	fileSet := token.NewFileSet()
	packages, err := parser.ParseDir(fileSet, g.path, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	for name, pkg := range packages {
		writer := g.writerFactory.CreateWriter(name)
		err := g.generatePackage(writer, fileSet, name, pkg)
		if err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) ensureDir() error {
	stat, err := os.Stat(g.path)
	if err != nil {
		return errors.Wrapf(err, "failed to retrieve stats for given path: %s", g.path)
	}

	if !stat.IsDir() {
		return errors.Errorf("not a directory: %s", g.path)
	}

	return nil
}

//
func (g *Generator) generatePackage(w io.Writer, fileSet *token.FileSet, pkgName string, pkg *ast.Package) error {
	// REF: https://stackoverflow.com/questions/55377694/how-to-find-full-package-import-from-callexpr
	files := make([]*ast.File, 0)
	for _, file := range pkg.Files {
		files = append(files, file)
	}

	info := &types.Info{
		Types:      make(map[ast.Expr]types.TypeAndValue),
		Defs:       make(map[*ast.Ident]types.Object),
		Uses:       make(map[*ast.Ident]types.Object),
		Implicits:  make(map[ast.Node]types.Object),
		Selections: make(map[*ast.SelectorExpr]*types.Selection),
		Scopes:     make(map[ast.Node]*types.Scope),
		InitOrder:  make([]*types.Initializer, 0),
	}

	conf := types.Config{Importer: importer.ForCompiler(fileSet, "source", nil)}
	checkedPackage, err := conf.Check(pkgName, fileSet, files, info)
	if err != nil {
		fmt.Print(err)
	}

	var _ = checkedPackage

	f := jen.NewFile(pkgName)
	f.HeaderComment("Code generated by Piper. DO NOT EDIT.")
	// f.PackageComment("+build !piper")

	g.info = info
	g.file = f

	for _, file := range pkg.Files {
		// ast.Walk(NewPipeGenerator(f, info), file)
		ast.Walk(g, file)
	}

	_, _ = fmt.Fprintf(w, "%#v", f)

	return nil
}

// Visit visits each node in an ASP tree.
func (g *Generator) Visit(node ast.Node) ast.Visitor {
	if decl, ok := node.(*ast.GenDecl); ok {
		if !g.isPipe(decl) {
			return g
		}

		for _, spec := range decl.Specs {
			if spec, ok := spec.(*ast.TypeSpec); ok {
				if structType, ok := spec.Type.(*ast.StructType); ok {
					g.genPipe(spec, structType)
				}
			}
		}
	}

	return g
}

func (g *Generator) isPipe(node *ast.GenDecl) bool {
	if node.Doc == nil {
		return false
	}

	for _, c := range node.Doc.List {
		if pipeRegex.MatchString(c.Text) {
			return true
		}
	}

	return false
}

// nolint:funlen,gocyclo // disable funlen and gocyclo linting since this is a complicated function.
func (g *Generator) genPipe(nodeSpec *ast.TypeSpec, structType *ast.StructType) {
	funcStmt := g.file.Func().Params(jen.Id("p").Op("*").Id(nodeSpec.Name.Name)).Id(defaultFunctionName)

	stages := make([]*stage, 0)
	lastParamIndex := 0

	for _, field := range structType.Fields.List {
		fieldType, ok := g.info.Types[field.Type]
		if !ok {
			continue
		}

		var functor *Functor = nil
		var stageType StageType

		switch fieldType := fieldType.Type.(type) {
		case *types.Signature:
			functor = &Functor{
				name:      "",
				signature: fieldType,
			}
			stageType = StageTypeFunction
		case *types.Named:
			functor = g.getFunctor(fieldType)
			stageType = StageTypeFunctor
		}

		if functor != nil {
			for _, id := range field.Names {
				var paramIndicies []int
				params := functor.signature.Params()
				if params != nil {
					paramIndicies = make([]int, params.Len())
					for i := 0; i < params.Len(); i++ {
						paramIndicies[i] = lastParamIndex + i
					}
					lastParamIndex += params.Len()
				}

				stages = append(stages, &stage{
					name:         id.Name,
					stateType:    stageType,
					functor:      functor,
					paramIndices: paramIndicies,
				})
			}
		}

		// fmt.Println(stages)
		var _ = fieldType
	}

	params := stages[0].functor.signature.Params()
	// results := stages[len(stages) - 1].signature.Results()

	prevInputs := make([]jen.Code, params.Len())

	paramStmts := make([]jen.Code, 0)
	for i := 0; i < params.Len(); i++ {
		p := params.At(i)
		t := p.Type()
		pname := jen.Id(fmt.Sprintf("v%d", stages[0].paramIndices[i]))
		paramStmts = append(paramStmts, g.getQualifiedName(pname, t))
		prevInputs[i] = jen.Id(fmt.Sprintf("v%d", stages[0].paramIndices[i]))
	}

	results := stages[len(stages)-1].functor.signature.Results()
	resultTypes := make([]jen.Code, 0)
	for i := 0; i < results.Len(); i++ {
		p := results.At(i)
		resultTypes = append(resultTypes, g.getQualifiedName(jen.Empty(), p.Type()))
	}

	varCount := params.Len()

	funcStmt = funcStmt.Params(paramStmts...)

	if results.Len() == 1 {
		funcStmt = funcStmt.List(resultTypes...)
	} else if results.Len() > 1 {
		funcStmt = funcStmt.Parens(jen.List(resultTypes...))
	}

	funcStmt.BlockFunc(func(group *jen.Group) {
		var output []jen.Code

		for i := 0; i < len(stages); i++ {
			results := stages[i].functor.signature.Results()
			output = make([]jen.Code, results.Len())
			for j := 0; j < results.Len(); j++ {
				output[j] = jen.Id(fmt.Sprintf("v%d", varCount))
				varCount++
			}
			if stages[i].stateType == StageTypeFunction {
				group.List(output...).Op(":=").Id("p").Dot(stages[i].name).Call(prevInputs...)
			} else if stages[i].stateType == StageTypeFunctor {
				group.List(output...).Op(":=").Id("p").Dot(stages[i].name).Dot(stages[i].functor.name).Call(prevInputs...)
			}

			prevInputs = output
		}

		group.Return(output...)
	}).Line()
}

func (g *Generator) getQualifiedName(stmt *jen.Statement, t types.Type) *jen.Statement {
	switch t := t.(type) {
	case *types.Named:
		return stmt.Qual(t.Obj().Pkg().Name(), t.Obj().Name())
	case *types.Basic:
		return stmt.Id(t.Name())
	}

	panic("cannot reach here")
}

func (g *Generator) getFunctor(name *types.Named) *Functor {
	functor, ok := g.functors[name]
	if !ok {
		if underlyingType, ok := name.Underlying().(*types.Interface); ok {
			if underlyingType.NumMethods() != 1 {
				return nil
			}

			method := underlyingType.Method(0)
			signature, ok := method.Type().(*types.Signature)
			if !ok {
				return nil
			}

			functor = &Functor{
				name:      method.Name(),
				signature: signature,
			}

			g.functors[name] = functor
			return functor
		}
	}

	return functor
}
