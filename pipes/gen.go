package pipes

import (
	"fmt"
	"github.com/dave/jennifer/jen"
	"github.com/pkg/errors"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io"
	"os"
)

type Functor struct {
	name string
	signature *types.Signature
}

// Generator ...
type Generator struct {
	path string
	file *jen.File
	info *types.Info
	functors map[*types.Named]*Functor
	writerFactory WriterFactory
}

// NewGenerator ...
func NewGenerator(path string, opts ...Option) *Generator {
	generator := &Generator{
		path: path,
		functors: map[*types.Named]*Functor{},
	}

	for _, opt := range opts {
		opt(generator)
	}

	if generator.writerFactory == nil {
		generator.writerFactory = NewStringWriterFactory()
	}

	return generator
}

// Execute ...
func (g *Generator) Execute() error {
	if err := g.ensureDir(); err != nil {
		return err
	}

	fileSet := token.NewFileSet()
	packages, err := parser.ParseDir(fileSet, g.path, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	for name, pkg := range packages {
		writer := g.writerFactory.CreateWriter(name)
		err := g.generatePackage(writer, fileSet, name, pkg)
		if err != nil {
			return err
		}
	}

	//set := token.NewFileSet()
	//packages, err := parser.ParseDir(set, g.path, nil, parser.ParseComments)
	//if err != nil {
	//	return err
	//}
	//
	//for _, pkg := range packages {
	//	for path, file := range pkg.Files {
	//		for _, decl := range file.Decls {
	//
	//			funcDecl, ok := decl.(*ast.FuncDecl)
	//			if !ok {
	//				continue
	//			}
	//
	//			isPiper, err := g.isPiper(funcDecl)
	//			if err != nil {
	//				return nil
	//			}
	//
	//			// Skip if not piper.
	//			if !isPiper {
	//				continue
	//			}
	//
	//			fmt.Print(funcDecl.Pos())
	//		}
	//
	//		genPath := fmt.Sprintf("%s_gen.go", path[0:len(path)-3])
	//		fmt.Print(genPath)
	//
	//		output, err := os.Create(genPath)
	//		if err != nil {
	//			return err
	//		}
	//
	//		file.Comments = []*ast.CommentGroup{
	//			{List: []*ast.Comment{
	//				{
	//					Text:  "// +build !piper\r\n",
	//				},
	//			}},
	//		}
	//
	//		err = printer.Fprint(output, set, file)
	//		if err != nil {
	//			_ = output.Close()
	//			return err
	//		}
	//
	//		err = output.Close()
	//		if err != nil {
	//			return err
	//		}
	//	}
	//}

	return nil
}

func (g *Generator) ensureDir() error {
	stat, err := os.Stat(g.path)
	if err != nil {
		return errors.Wrapf(err, "failed to retrieve stats for given path: %s", g.path)
	}

	if !stat.IsDir() {
		return errors.Errorf("not a directory: %s", g.path)
	}

	return nil
}

func (g *Generator) isPiper(decl *ast.FuncDecl) (bool, error) {
	return true, nil
}

//
func (g *Generator) generatePackage(w io.Writer, fileSet *token.FileSet, pkgName string, pkg *ast.Package) error {
	// REF: https://stackoverflow.com/questions/55377694/how-to-find-full-package-import-from-callexpr
	files := make([]*ast.File, 0)
	for _, file := range pkg.Files {
		files = append(files, file)
	}

	info := &types.Info {
		Types:      make(map[ast.Expr]types.TypeAndValue),
		Defs:       make(map[*ast.Ident]types.Object),
		Uses:       make(map[*ast.Ident]types.Object),
		Implicits:  make(map[ast.Node]types.Object),
		Selections: make(map[*ast.SelectorExpr]*types.Selection),
		Scopes:     make(map[ast.Node]*types.Scope),
		InitOrder:  make([]*types.Initializer, 0),
	}

	conf := types.Config{Importer: importer.ForCompiler(fileSet, "source", nil)}
	checkedPackage, err := conf.Check(pkgName, fileSet, files, info)
	if err != nil {
		fmt.Print(err)
	}

	var _ = checkedPackage

	f := jen.NewFile(pkgName)
	f.HeaderComment("Code generated by Piper. DO NOT EDIT.")
	//f.PackageComment("+build !piper")

	g.info = info
	g.file = f

	for _, file := range pkg.Files {
		//ast.Walk(NewPipeGenerator(f, info), file)
		ast.Walk(g, file)
	}

	_, _  = fmt.Fprintf(w, "%#v", f)

	return nil
}

func (g *Generator) Visit(node ast.Node) ast.Visitor {
	switch node := node.(type) {
	case *ast.GenDecl:
		if !g.isPipe(node) {
			return g
		}

		for _, spec := range node.Specs {
			switch nodeSpec := spec.(type) {
			case *ast.TypeSpec:
				switch structType := nodeSpec.Type.(type) {
				case *ast.StructType:
					g.genPipe(nodeSpec, structType)
				}
			}
		}
	}
	return g
}

func (g *Generator) isPipe(node *ast.GenDecl) bool {
	if node.Doc == nil {
		return false
	}

	for _, c := range node.Doc.List {
		if pipeRegex.MatchString(c.Text) {
			return true
		}
	}

	return false
}

func (g *Generator) genPipe(nodeSpec *ast.TypeSpec, structType *ast.StructType) {
	funcStmt := g.file.Func().Params(jen.Id("p").Op("*").Id(nodeSpec.Name.Name)).Id(defaultFunctionName)

	stages := make([]*stage, 0)
	lastParamIndex := 0

	for _, field := range structType.Fields.List {
		fieldType, ok := g.info.Types[field.Type]
		if !ok {
			continue
		}

		var functor *Functor = nil
		var stageType StageType

		switch fieldType := fieldType.Type.(type) {
		case *types.Signature:
			functor = &Functor{
				name:      "",
				signature: fieldType,
			}
			stageType = StageTypeFunction
		case *types.Named:
			functor = g.getFunctor(fieldType)
			stageType = StageTypeFunctor
		}

		if functor != nil {
			for _, id := range field.Names {
				var paramIndicies []int
				params := functor.signature.Params()
				if params != nil {
					paramIndicies = make([]int, params.Len())
					for i := 0; i < params.Len(); i++ {
						paramIndicies[i] = lastParamIndex + i
					}
					lastParamIndex += params.Len()
				}

				stages = append(stages, &stage{
					name:         id.Name,
					stateType:    stageType,
					functor:    functor,
					paramIndices: paramIndicies,
				})
			}
		}


		//fmt.Println(stages)
		var _ = fieldType
	}

	params := stages[0].functor.signature.Params()
	//results := stages[len(stages) - 1].signature.Results()

	prevInputs := make([]jen.Code, params.Len())

	paramStmts := make([]jen.Code, 0)
	for i := 0; i < params.Len(); i++ {
		p := params.At(i)
		t := p.Type()
		pname := jen.Id(fmt.Sprintf("v%d", stages[0].paramIndices[i]))
		paramStmts = append(paramStmts, g.getQualifiedName(pname, t))
		prevInputs[i] = jen.Id(fmt.Sprintf("v%d", stages[0].paramIndices[i]))
	}

	results := stages[len(stages) - 1].functor.signature.Results()
	resultTypes := make([]jen.Code, 0)
	for i := 0; i < results.Len(); i++ {
		p := results.At(i)
		resultTypes = append(resultTypes, g.getQualifiedName(jen.Empty(), p.Type()))
	}

	varCount := params.Len()

	funcStmt = funcStmt.Params(paramStmts...)

	if results.Len() == 1 {
		funcStmt = funcStmt.List(resultTypes...)
	} else if results.Len() > 1 {
		funcStmt = funcStmt.Parens(jen.List(resultTypes...))
	}

	funcStmt.BlockFunc(func(group *jen.Group) {
		var output []jen.Code

		for i := 0; i < len(stages); i++ {
			results := stages[i].functor.signature.Results()
			output = make([]jen.Code, results.Len())
			for j := 0; j < results.Len(); j++ {
				output[j] = jen.Id(fmt.Sprintf("v%d", varCount))
				varCount += 1
			}
			if stages[i].stateType == StageTypeFunction {
				group.List(output...).Op(":=").Id("p").Dot(stages[i].name).Call(prevInputs...)
			} else if stages[i].stateType == StageTypeFunctor {
				group.List(output...).Op(":=").Id("p").Dot(stages[i].name).Dot(stages[i].functor.name).Call(prevInputs...)
			}

			prevInputs = output
		}

		group.Return(output...)
	}).Line()
}

func (g *Generator) getQualifiedName(stmt *jen.Statement, t types.Type) *jen.Statement{
	switch t := t.(type) {
	case *types.Named:
		return stmt.Qual(t.Obj().Pkg().Name(), t.Obj().Name())
	case *types.Basic:
		return stmt.Id(t.Name())
	}

	panic("cannot reach here")
}

func (g *Generator) getFunctor(name *types.Named) *Functor {
	functor, ok := g.functors[name]
	if !ok {
		switch underlyingType := name.Underlying().(type) {
		case *types.Interface:
			if underlyingType.NumMethods() != 1 {
				return nil
			}

			method := underlyingType.Method(0)
			signature, ok := method.Type().(*types.Signature)
			if !ok {
				return nil
			}

			functor = &Functor{
				name:      method.Name(),
				signature: signature,
			}

			g.functors[name] = functor
			return functor
		}
	}

	return functor
}

//func (g *Generator) Visit(node ast.Node) ast.Visitor {
//	switch node := node.(type) {
//	case *ast.GenDecl:
//		for _, spec := range node.Specs {
//			switch node := spec.(type) {
//			case *ast.TypeSpec:
//				switch nodeType := node.Type.(type) {
//				case *ast.StructType:
//					g.file.Type().Id(node.Name.Name).StructFunc(func(group *jen.Group) {
//						for _, field := range nodeType.Fields.List {
//							ids := make([]jen.Code, 0, len(field.Names))
//							for _, name := range field.Names {
//								ids = append(ids, jen.Id(name.Name))
//							}
//							stmt := group.List(ids...)
//
//							typeInfo, ok := g.info.Types[field.Type]
//							if !ok {
//								fmt.Print("failed")
//							}
//
//							switch fieldType := typeInfo.Type.(type) {
//							//case *types.Basic:
//							//	stmt.Qual("", fieldType.Name())
//							case *types.Named:
//								stmt.Qual(fieldType.Obj().Pkg().Path(), fieldType.Obj().Name())
//							default:
//								stmt.Qual("", fieldType.String())
//							}
//						}
//					})
//				}
//			}
//		}
//	}
//	return g
//}